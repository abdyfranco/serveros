.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LibIDN 3"
.TH LibIDN 3 "2017-05-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::LibIDN \- Perl bindings for GNU Libidn
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::LibIDN \*(Aq:all\*(Aq;
\&
\&  idn_to_ascii("Ra\*:ksmo\*:rga\*os.Josef\*8on.ORG") eq
\&    idn_to_ascii(idn_to_unicode("xn\-\-rksmrgs\-5wao1o.josefsson.org"));
\&
\&  idn_prep_name("LibU\*:DN") eq "libu\*:dn";
\&
\&  idn_punycode_encode("kistenmo\*:hre") eq
\&    idn_punycode_encode(idn_punycode_decode("kistenmhre\-kcb"));
\&
\&  my $errpos;
\&  tld_check("me\*`rle.se", $errpos) eq undef;
\&    $errpos == 1;
\&
\&  tld_get("mainbase.mars") eq "mars";
\&
\&  my $hashref = Net::LibIDN::tld_get_table("de");
\&
\&  print "$hashref\->{version}\en";
\&  foreach (@{$hashref\->{valid}})
\&  {
\&    print "Unicode range from ".$_\->{start}." to ".$_\->{end}."\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Provides bindings for \s-1GNU\s0 Libidn, a C library for handling Internationalized
Domain Names according to \s-1IDNA \s0(\s-1RFC 3490\s0), in a way very much inspired by
Turbo Fredriksson's PHP-IDN.
.SS "Functions"
.IX Subsection "Functions"
.ie n .IP "\fBNet::LibIDN::idn_to_ascii\fR(\fI\fI$clear_hostname\fI\fR, [\fI\fI$charset\fI\fR, [\fI\fI$flags\fI\fR]]);" 4
.el .IP "\fBNet::LibIDN::idn_to_ascii\fR(\fI\f(CI$clear_hostname\fI\fR, [\fI\f(CI$charset\fI\fR, [\fI\f(CI$flags\fI\fR]]);" 4
.IX Item "Net::LibIDN::idn_to_ascii($clear_hostname, [$charset, [$flags]]);"
Converts \fI\f(CI$clear_hostname\fI\fR which might contain characters outside
the range allowed in \s-1DNS\s0 names, to \s-1IDNA ACE.\s0 If \fI\f(CI$charset\fI\fR is
specified, treats string as being encoded in it, otherwise
assumes it is \s-1ISO\-8859\-1\s0 encoded. If flag
\&\fB\s-1IDNA_ALLOW_UNASSIGNED\s0\fR is set in \fI\f(CI$flags\fI\fR, accepts also unassigned
Unicode characters, if \fB\s-1IDNA_USE_STD3_ASCII_RULES\s0\fR is set, accepts
only \s-1ASCII LDH\s0 characters (letter-digit-hyphen). Flags can be
combined with ||. Returns result of conversion or \fBundef\fR on
error.
.ie n .IP "\fBNet::LibIDN::idn_to_unicode\fR(\fI\fI$idn_hostname\fI\fR, [\fI\fI$charset\fI\fR, [\fI\fI$flags\fI\fR]]);" 4
.el .IP "\fBNet::LibIDN::idn_to_unicode\fR(\fI\f(CI$idn_hostname\fI\fR, [\fI\f(CI$charset\fI\fR, [\fI\f(CI$flags\fI\fR]]);" 4
.IX Item "Net::LibIDN::idn_to_unicode($idn_hostname, [$charset, [$flags]]);"
Converts \s-1ASCII \s0\fI\f(CI$idn_hostname\fI\fR, which might be \s-1IDNA ACE\s0
encoded, into the decoded form in \fI\f(CI$charset\fI\fR or \s-1ISO\-8859\-1.\s0 Flags
are interpreted as above. Returns result of conversion
or \fBundef\fR on error.
.ie n .IP "\fBNet::LibIDN::idn_punycode_encode\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_punycode_encode\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_punycode_encode($string, [$charset]);"
Encodes \fI\f(CI$string\fI\fR into \*(L"punycode\*(R" (\s-1RFC 3492\s0). If \fI\f(CI$charset\fI\fR
is present, treats \fI\f(CI$string\fI\fR as being in \fI\f(CI$charset\fI\fR, otherwise
uses \s-1ISO\-8859\-1.\s0 Returns result of conversion
or \fBundef\fR on error.
.ie n .IP "\fBNet::LibIDN::idn_punycode_decode\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_punycode_decode\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_punycode_decode($string, [$charset]);"
Decodes \fI\f(CI$string\fI\fR from \*(L"punycode\*(R" (\s-1RFC 3492\s0). If \fI\f(CI$charset\fI\fR
is present, result is converted to \fI\f(CI$charset\fI\fR, otherwise
it is converted to \s-1ISO\-8859\-1.\s0 Returns result of conversion
or \fBundef\fR on error.
.ie n .IP "\fBNet::LibIDN::idn_prep_name\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_name\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_name($string, [$charset]);"
.PD 0
.ie n .IP "\fBNet::LibIDN::idn_prep_kerberos5\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_kerberos5\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_kerberos5($string, [$charset]);"
.ie n .IP "\fBNet::LibIDN::idn_prep_node\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_node\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_node($string, [$charset]);"
.ie n .IP "\fBNet::LibIDN::idn_prep_resource\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_resource\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_resource($string, [$charset]);"
.ie n .IP "\fBNet::LibIDN::idn_prep_plain\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_plain\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_plain($string, [$charset]);"
.ie n .IP "\fBNet::LibIDN::idn_prep_trace\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_trace\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_trace($string, [$charset]);"
.ie n .IP "\fBNet::LibIDN::idn_prep_sasl\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_sasl\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_sasl($string, [$charset]);"
.ie n .IP "\fBNet::LibIDN::idn_prep_iscsi\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_iscsi\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_iscsi($string, [$charset]);"
.PD
Performs \*(L"stringprep\*(R" (\s-1RFC 3454\s0) on \f(CW$string\fR according to the named
profile (e.g. *_name \-> \*(L"nameprep\*(R" (\s-1RFC 3491\s0)).
If \fI\f(CI$charset\fI\fR is present, converts from and to this charset before and after
the operation respectively. Returns result string, or \fBundef\fR on error.
.ie n .IP "\fBNet::LibIDN::tdl_check\fR(\fI\fI$string\fI\fR, \fI\fI$errpos\fI\fR, [\fI\fI$charset\fI\fR, [\fI\fI$tld\fI\fR]]);" 4
.el .IP "\fBNet::LibIDN::tdl_check\fR(\fI\f(CI$string\fI\fR, \fI\f(CI$errpos\fI\fR, [\fI\f(CI$charset\fI\fR, [\fI\f(CI$tld\fI\fR]]);" 4
.IX Item "Net::LibIDN::tdl_check($string, $errpos, [$charset, [$tld]]);"
Checks whether or not \fI\f(CI$string\fI\fR conforms to the restrictions on the sets
of valid characters defined by \s-1TLD\s0 authorities around the World. Treats
\&\fI\f(CI$string\fI\fR as a hostname if \fI\f(CI$tld\fI\fR is not present, determining the \s-1TLD\s0
from the hostname. If \fI\f(CI$tld\fI\fR is present, uses the restrictions defined
by the parties responsible for \s-1TLD \s0\fI\f(CI$tld\fI\fR. \fI\f(CI$charset\fI\fR may be used to
specify the character set the \fI\f(CI$string\fI\fR is in. Should an invalid character
be detected, returns 0 and the 0\-based position of the offending character
in \fI\f(CI$errpos\fI\fR. In case of other failure conditions, \fI\f(CI$errpos\fI\fR is not touched,
and \fBundef\fR is returned. Should \fI\f(CI$string\fI\fR conform to the \s-1TLD\s0 restrictions,
1 is returned.
.ie n .IP "\fBNet::LibIDN::tld_get\fR(\fI\fI$hostname\fI\fR);" 4
.el .IP "\fBNet::LibIDN::tld_get\fR(\fI\f(CI$hostname\fI\fR);" 4
.IX Item "Net::LibIDN::tld_get($hostname);"
Returns top level domain of \fI\f(CI$hostname\fI\fR, or \fBundef\fR if an error
occurs or if no top level domain was found.
.ie n .IP "\fBNet::LibIDN::tld_get_table\fR(\fI\fI$tld\fI\fR);" 4
.el .IP "\fBNet::LibIDN::tld_get_table\fR(\fI\f(CI$tld\fI\fR);" 4
.IX Item "Net::LibIDN::tld_get_table($tld);"
Retrieves a hash reference with the \s-1TLD\s0 restriction info of given
\&\s-1TLD \s0\fI\f(CI$tld\fI\fR, or \fBundef\fR if \fI\f(CI$tld\fI\fR is not found. The hash ref contains the
following fields:
.RS 4
.IP "\(bu" 4
\&\fI\f(CI$h\fI\-\fR>\fI{name}\fR ... name of \s-1TLD\s0
.IP "\(bu" 4
\&\fI\f(CI$h\fI\-\fR>\fI{version}\fR ... version string of this restriction table
.IP "\(bu" 4
\&\fI\f(CI$h\fI\-\fR>\fI{nvalid}\fR ... number of Unicode intervals
.IP "\(bu" 4
\&\fI\f(CI$h\fI\-\fR>\fI{valid}\fR ...  [ {\fIstart\fR => number, \fIend\fR => number}, ...] ... Unicode intervals
.RE
.RS 4
.RE
.SS "Limitations"
.IX Subsection "Limitations"
There is currently no support for Perl's unicode capabilities (man perlunicode).
All input strings are assumed to be octet strings, all output strings are 
generated as octet strings. Thus, if you require Perl's unicode features, you 
will have to convert your strings manually. For example:
.Sp
.RS 4
use Encode;
.Sp
use Data::Dumper;
.Sp
print Dumper(Net::LibIDN::idn_to_unicode('xn\*(--uro\-j50a.com', 'utf\-8'));
.Sp
print Dumper(decode('utf\-8', Net::LibIDN::idn_to_unicode('xn\*(--uro\-j50a.com', 'utf\-8')));
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
Thomas Jacob, http://internet24.de
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \s-1RFC 3454, RFC 3490\-3492,\s0 http://www.gnu.org/software/libidn.
