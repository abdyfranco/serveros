.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SpamAssassin::BayesStore::SQL 3"
.TH Mail::SpamAssassin::BayesStore::SQL 3 "2016-06-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SpamAssassin::BayesStore::SQL \- SQL Bayesian Storage Module Implementation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implementes a \s-1SQL\s0 based bayesian storage module.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
public class (Mail::SpamAssassin::BayesStore::SQL) new (Mail::Spamassassin::Plugin::Bayes \f(CW$bayes\fR)
.PP
Description:
This methods creates a new instance of the Mail::SpamAssassin::BayesStore::SQL
object.  It expects to be passed an instance of the Mail::SpamAssassin:Bayes
object which is passed into the Mail::SpamAssassin::BayesStore parent object.
.PP
This method sets up the database connection and determines the username to
use in queries.
.SS "tie_db_readonly"
.IX Subsection "tie_db_readonly"
public instance (Boolean) tie_db_readonly ();
.PP
Description:
This method ensures that the database connection is properly setup
and working.  If necessary it will initialize a user's bayes variables
so that they can begin using the database immediately.
.SS "tie_db_writable"
.IX Subsection "tie_db_writable"
public instance (Boolean) tie_db_writable ()
.PP
Description:
This method ensures that the database connection is properly setup
and working. If necessary it will initialize a users bayes variables
so that they can begin using the database immediately.
.SS "untie_db"
.IX Subsection "untie_db"
public instance () untie_db ()
.PP
Description:
Disconnects from an \s-1SQL\s0 server.
.SS "calculate_expire_delta"
.IX Subsection "calculate_expire_delta"
public instance (%) calculate_expire_delta (Integer \f(CW$newest_atime\fR,
                                             Integer \f(CW$start\fR,
                                             Integer \f(CW$max_expire_mult\fR)
.PP
Description:
This method performs a calculation on the data to determine the optimum
atime for token expiration.
.SS "token_expiration"
.IX Subsection "token_expiration"
public instance (Integer, Integer,
                 Integer, Integer) token_expiration(\e% \f(CW$opts\fR,
                                                    Integer \f(CW$newdelta\fR,
                                                    @ \f(CW@vars\fR)
.PP
Description:
This method performs the database specific expiration of tokens based on
the passed in \f(CW$newdelta\fR and \f(CW@vars\fR.
.SS "sync_due"
.IX Subsection "sync_due"
public instance (Boolean) sync_due ()
.PP
Description:
This method determines if a database sync is currently required.
.PP
Unused for \s-1SQL\s0 based implementation.
.SS "seen_get"
.IX Subsection "seen_get"
public instance (String) seen_get (string \f(CW$msgid\fR)
.PP
Description:
This method retrieves the stored value, if any, for \f(CW$msgid\fR.  The return value
is the stored string ('s' for spam and 'h' for ham) or undef if \f(CW$msgid\fR is not
found.
.SS "seen_put"
.IX Subsection "seen_put"
public (Boolean) seen_put (string \f(CW$msgid\fR, char \f(CW$flag\fR)
.PP
Description:
This method records \f(CW$msgid\fR as the type given by \f(CW$flag\fR.  \f(CW$flag\fR is one of
two values 's' for spam and 'h' for ham.
.SS "seen_delete"
.IX Subsection "seen_delete"
public instance (Boolean) seen_delete (string \f(CW$msgid\fR)
.PP
Description:
This method removes \f(CW$msgid\fR from the database.
.SS "get_storage_variables"
.IX Subsection "get_storage_variables"
public instance (@) get_storage_variables ()
.PP
Description:
This method retrieves the various administrative variables used by
the Bayes process and database.
.PP
The values returned in the array are in the following order:
.PP
0: scan count base
.PP
1: number of spam
.PP
2: number of ham
.PP
3: number of tokens in db
.PP
4: last expire atime
.PP
5: oldest token in db atime
.PP
6: db version value
.PP
7: last journal sync
.PP
8: last atime delta
.PP
9: last expire reduction count
.PP
10: newest token in db atime
.SS "dump_db_toks"
.IX Subsection "dump_db_toks"
public instance () dump_db_toks (String \f(CW$template\fR, String \f(CW$regex\fR, Array \f(CW@vars\fR)
.PP
Description:
This method loops over all tokens, computing the probability for the token and then
printing it out according to the passed in token.
.SS "set_last_expire"
.IX Subsection "set_last_expire"
public instance (Boolean) set_last_expire (Integer \f(CW$time\fR)
.PP
Description:
This method sets the last expire time.
.SS "get_running_expire_tok"
.IX Subsection "get_running_expire_tok"
public instance (String \f(CW$time\fR) get_running_expire_tok ()
.PP
Description:
This method determines if an expire is currently running and returns
the last time set.
.PP
There can be multiple times, so we just pull the greatest (most recent)
value.
.SS "set_running_expire_tok"
.IX Subsection "set_running_expire_tok"
public instance (String \f(CW$time\fR) set_running_expire_tok ()
.PP
Description:
This method sets the time that an expire starts running.
.SS "remove_running_expire_tok"
.IX Subsection "remove_running_expire_tok"
public instance (Boolean) remove_running_expire_tok ()
.PP
Description:
This method removes the row in the database that indicates that
and expire is currently running.
.SS "tok_get"
.IX Subsection "tok_get"
public instance (Integer, Integer, Integer) tok_get (String \f(CW$token\fR)
.PP
Description:
This method retrieves a specificed token (\f(CW$token\fR) from the database
and returns it's spam_count, ham_count and last access time.
.SS "tok_get_all"
.IX Subsection "tok_get_all"
public instance (\e@) tok_get (@ \f(CW$tokens\fR)
.PP
Description:
This method retrieves the specified tokens (\f(CW$tokens\fR) from storage and returns
an array ref of arrays spam count, ham acount and last access time.
.SS "tok_count_change"
.IX Subsection "tok_count_change"
public instance (Boolean) tok_count_change (Integer \f(CW$spam_count\fR,
					    Integer \f(CW$ham_count\fR,
					    String \f(CW$token\fR,
					    String \f(CW$atime\fR)
.PP
Description:
This method takes a \f(CW$spam_count\fR and \f(CW$ham_count\fR and adds it to
\&\f(CW$tok\fR along with updating \f(CW$tok\fRs atime with \f(CW$atime\fR.
.SS "multi_tok_count_change"
.IX Subsection "multi_tok_count_change"
public instance (Boolean) multi_tok_count_change (Integer \f(CW$spam_count\fR,
 					          Integer \f(CW$ham_count\fR,
				 	          \e% \f(CW$tokens\fR,
					          String \f(CW$atime\fR)
.PP
Description:
This method takes a \f(CW$spam_count\fR and \f(CW$ham_count\fR and adds it to all
of the tokens in the \f(CW$tokens\fR hash ref along with updating each token's
atime with \f(CW$atime\fR.
.SS "nspam_nham_get"
.IX Subsection "nspam_nham_get"
public instance ($spam_count, \f(CW$ham_count\fR) nspam_nham_get ()
.PP
Description:
This method retrieves the total number of spam and the total number of
ham learned.
.SS "nspam_nham_change"
.IX Subsection "nspam_nham_change"
public instance (Boolean) nspam_nham_change (Integer \f(CW$num_spam\fR,
                                             Integer \f(CW$num_ham\fR)
.PP
Description:
This method updates the number of spam and the number of ham in the database.
.SS "tok_touch"
.IX Subsection "tok_touch"
public instance (Boolean) tok_touch (String \f(CW$token\fR,
                                     String \f(CW$atime\fR)
.PP
Description:
This method updates the given tokens (\f(CW$token\fR) atime.
.PP
The assumption is that the token already exists in the database.
.SS "tok_touch_all"
.IX Subsection "tok_touch_all"
public instance (Boolean) tok_touch (\e@ \f(CW$tokens\fR
                                     String \f(CW$atime\fR)
.PP
Description:
This method does a mass update of the given list of tokens \f(CW$tokens\fR, if the existing token
atime is < \f(CW$atime\fR.
.PP
The assumption is that the tokens already exist in the database.
.PP
We should never be touching more than N_SIGNIFICANT_TOKENS, so we can make
some assumptions about how to handle the data (ie no need to batch like we
do in tok_get_all)
.SS "cleanup"
.IX Subsection "cleanup"
public instance (Boolean) cleanup ()
.PP
Description:
This method perfoms any cleanup necessary before moving onto the next
operation.
.SS "get_magic_re"
.IX Subsection "get_magic_re"
public instance get_magic_re (String)
.PP
Description:
This method returns a regexp which indicates a magic token.
.PP
Unused in \s-1SQL\s0 implementation.
.SS "sync"
.IX Subsection "sync"
public instance (Boolean) sync (\e% \f(CW$opts\fR)
.PP
Description:
This method performs a sync of the database
.SS "perform_upgrade"
.IX Subsection "perform_upgrade"
public instance (Boolean) perform_upgrade (\e% \f(CW$opts\fR);
.PP
Description:
Performs an upgrade of the database from one version to another, not
currently used in this implementation.
.SS "clear_database"
.IX Subsection "clear_database"
public instance (Boolean) clear_database ()
.PP
Description:
This method deletes all records for a particular user.
.PP
Callers should be aware that any errors returned by this method
could cause the database to be inconsistent for the given user.
.SS "backup_database"
.IX Subsection "backup_database"
public instance (Boolean) backup_database ()
.PP
Description:
This method will dump the users database in a machine readable format.
.SS "restore_database"
.IX Subsection "restore_database"
public instance (Boolean) restore_database (String \f(CW$filename\fR, Boolean \f(CW$showdots\fR)
.PP
Description:
This method restores a database from the given filename, \f(CW$filename\fR.
.PP
Callers should be aware that any errors returned by this method
could causes the database to be inconsistent for the given user.
.SS "db_readable"
.IX Subsection "db_readable"
public instance (Boolean) \fIdb_readable()\fR
.PP
Description:
This method returns a boolean value indicating if the database is in a
readable state.
.SS "db_writable"
.IX Subsection "db_writable"
public instance (Boolean) \fIdb_writeable()\fR
.PP
Description:
This method returns a boolean value indicating if the database is in a
writable state.
.SH "Private Methods"
.IX Header "Private Methods"
.SS "_connect_db"
.IX Subsection "_connect_db"
private instance (Boolean) _connect_db ()
.PP
Description:
This method connects to the \s-1SQL\s0 database.
.SS "_get_db_version"
.IX Subsection "_get_db_version"
private instance (Integer) _get_db_version ()
.PP
Description:
Gets the current version of the database from the special global vars
tables.
.SS "_initialize_db"
.IX Subsection "_initialize_db"
private instance (Boolean) _initialize_db ()
.PP
Description:
This method will check to see if a user has had their bayes variables
initialized. If not then it will perform this initialization.
.SS "_put_token"
.IX Subsection "_put_token"
private instance (Boolean) _put_token (string \f(CW$token\fR,
                                       integer \f(CW$spam_count\fR,
                                       integer \f(CW$ham_count\fR,
				       string \f(CW$atime\fR)
.PP
Description:
This method performs the work of either inserting or updating a token in
the database.
.SS "_put_tokens"
.IX Subsection "_put_tokens"
private instance (Boolean) _put_tokens (\e% \f(CW$tokens\fR,
                                        integer \f(CW$spam_count\fR,
                                        integer \f(CW$ham_count\fR,
	 			        string \f(CW$atime\fR)
.PP
Description:
This method performs the work of either inserting or updating tokens in
the database.
.SS "_get_oldest_token_age"
.IX Subsection "_get_oldest_token_age"
private instance (Integer) _get_oldest_token_age ()
.PP
Description:
This method finds the atime of the oldest token in the database.
.PP
The use of min(atime) in the \s-1SQL\s0 is ugly and but really the most efficient
way of getting the oldest_token_age after we've done a mass expire.  It should
only be called at expire time.
.SS "_get_num_hapaxes"
.IX Subsection "_get_num_hapaxes"
private instance (Integer) _get_num_hapaxes ()
.PP
Description:
This method gets the total number of hapaxes (spam_count + ham_count == 1) in
the token database for a user.
.SS "_get_num_lowfreq"
.IX Subsection "_get_num_lowfreq"
private instance (Integer) _get_num_lowfreq ()
.PP
Description:
This method gets the total number of lowfreq tokens (spam_count < 8 and
ham_count < 8) in the token database for a user
.SS "_token_select_string"
.IX Subsection "_token_select_string"
private instance (String) _token_select_string
.PP
Description:
This method returns the string to be used in \s-1SELECT\s0 statements to represent
the token column.
.PP
The default is to use the \s-1RPAD\s0 function to pad the token out to 5 characters.
