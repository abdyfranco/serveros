.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SpamAssassin::BayesStore::MySQL 3"
.TH Mail::SpamAssassin::BayesStore::MySQL 3 "2016-06-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SpamAssassin::BayesStore::MySQL \- MySQL Specific Bayesian Storage Module Implementation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements a MySQL specific based bayesian storage module.  It
requires that you are running at least version 4.1 of MySQL, if you are running
a version of MySQL < 4.1 then several aspects of this module will fail and
possibly corrupt your bayes database data.
.PP
In addition, this module will support rollback on error, if you are
using the InnoDB database table type in MySQL.  For more information
please review the instructions in sql/README.bayes.
.SH "METHODS"
.IX Header "METHODS"
.SS "token_expiration"
.IX Subsection "token_expiration"
public instance (Integer, Integer,
                 Integer, Integer) token_expiration(\e% \f(CW$opts\fR,
                                                    Integer \f(CW$newdelta\fR,
                                                    @ \f(CW@vars\fR)
.PP
Description:
This method performs the database specific expiration of tokens based on
the passed in \f(CW$newdelta\fR and \f(CW@vars\fR.
.SS "seen_put"
.IX Subsection "seen_put"
public (Boolean) seen_put (string \f(CW$msgid\fR, char \f(CW$flag\fR)
.PP
Description:
This method records \f(CW$msgid\fR as the type given by \f(CW$flag\fR.  \f(CW$flag\fR is one of
two values 's' for spam and 'h' for ham.
.SS "seen_delete"
.IX Subsection "seen_delete"
public instance (Boolean) seen_delete (string \f(CW$msgid\fR)
.PP
Description:
This method removes \f(CW$msgid\fR from the database.
.SS "set_last_expire"
.IX Subsection "set_last_expire"
public instance (Boolean) set_last_expire (Integer \f(CW$time\fR)
.PP
Description:
This method sets the last expire time.
.SS "set_running_expire_tok"
.IX Subsection "set_running_expire_tok"
public instance (String \f(CW$time\fR) set_running_expire_tok ()
.PP
Description:
This method sets the time that an expire starts running.
.SS "remove_running_expire_tok"
.IX Subsection "remove_running_expire_tok"
public instance (Boolean) remove_running_expire_tok ()
.PP
Description:
This method removes the row in the database that indicates that
and expire is currently running.
.SS "nspam_nham_change"
.IX Subsection "nspam_nham_change"
public instance (Boolean) nspam_nham_change (Integer \f(CW$num_spam\fR,
                                             Integer \f(CW$num_ham\fR)
.PP
Description:
This method updates the number of spam and the number of ham in the database.
.SS "tok_touch"
.IX Subsection "tok_touch"
public instance (Boolean) tok_touch (String \f(CW$token\fR,
                                     String \f(CW$atime\fR)
.PP
Description:
This method updates the given tokens (\f(CW$token\fR) atime.
.PP
The assumption is that the token already exists in the database.
.SS "tok_touch_all"
.IX Subsection "tok_touch_all"
public instance (Boolean) tok_touch (\e@ \f(CW$tokens\fR
                                     String \f(CW$atime\fR)
.PP
Description:
This method does a mass update of the given list of tokens \f(CW$tokens\fR, if the existing token
atime is < \f(CW$atime\fR.
.PP
The assumption is that the tokens already exist in the database.
.PP
We should never be touching more than N_SIGNIFICANT_TOKENS, so we can make
some assumptions about how to handle the data (ie no need to batch like we
do in tok_get_all)
.SS "cleanup"
.IX Subsection "cleanup"
public instance (Boolean) cleanup ()
.PP
Description:
This method perfoms any cleanup necessary before moving onto the next
operation.
.SS "clear_database"
.IX Subsection "clear_database"
public instance (Boolean) clear_database ()
.PP
Description:
This method deletes all records for a particular user.
.PP
Callers should be aware that any errors returned by this method
could causes the database to be inconsistent for the given user.
.SH "Private Methods"
.IX Header "Private Methods"
.SS "_connect_db"
.IX Subsection "_connect_db"
private instance (Boolean) _connect_db ()
.PP
Description:
This method connects to the \s-1SQL\s0 database.
.SS "_initialize_db"
.IX Subsection "_initialize_db"
private instance (Boolean) _initialize_db ()
.PP
Description:
This method will check to see if a user has had their bayes variables
initialized. If not then it will perform this initialization.
.SS "_put_token"
.IX Subsection "_put_token"
private instance (Boolean) _put_token (string \f(CW$token\fR,
                                       integer \f(CW$spam_count\fR,
                                       integer \f(CW$ham_count\fR,
				       string \f(CW$atime\fR)
.PP
Description:
This method performs the work of either inserting or updating a token in
the database.
.SS "_put_tokens"
.IX Subsection "_put_tokens"
private instance (Boolean) _put_tokens (\e% \f(CW$tokens\fR,
                                        integer \f(CW$spam_count\fR,
                                        integer \f(CW$ham_count\fR,
			 	        string \f(CW$atime\fR)
.PP
Description:
This method performs the work of either inserting or updating tokens in
the database.
